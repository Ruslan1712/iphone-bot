import logging
import os
import json
from datetime import datetime
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, InputMediaPhoto
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes, filters

# ========== –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ==========
TOKEN = os.getenv("TOKEN")
CHANNEL_ID = "@apple_street_41"

if not TOKEN:
    raise ValueError("‚ùå –û—à–∏–±–∫–∞: –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.")

# –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
MAIN_MENU = [
    ["iPhone", "Samsung"],
    ["Dyson", "–û—Ç–∑—ã–≤—ã"],
    ["üì¶ –°–¥–µ–ª–∞—Ç—å –∑–∞–∫–∞–∑"],
    ["–ú—ã –≤ Telegram", "–ù–∞—à Instagram"]
]

DYSON_CATEGORIES = [
    ["–°—Ç–∞–π–ª–µ—Ä—ã"],
    ["–§–µ–Ω—ã"],
    ["–í—ã–ø—Ä—è–º–∏—Ç–µ–ª–∏"],
    ["üîô –ù–∞–∑–∞–¥"]
]

# –°–æ—Å—Ç–æ—è–Ω–∏–µ –∑–∞–∫–∞–∑–æ–≤
AWAITING_ORDER = {}

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–æ–≤
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

# ========== –ó–∞–≥—Ä—É–∑—á–∏–∫–∏ –¥–∞–Ω–Ω—ã—Ö ==========
def load_prices():
    try:
        with open("prices.json", "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        logging.error("‚ùå –§–∞–π–ª prices.json –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return {}

def load_dyson_stylers():
    try:
        with open("dyson_stylers.json", "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        logging.error("‚ùå –§–∞–π–ª dyson_stylers.json –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return {}

# ========== –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ==========
async def is_subscribed(user_id, context):
    try:
        member = await context.bot.get_chat_member(chat_id=CHANNEL_ID, user_id=user_id)
        return member.status in ["member", "administrator", "creator"]
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏: {e}")
        return False

# ========== –û—Å–Ω–æ–≤–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ ==========
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if not await is_subscribed(user_id, context):
        keyboard = ReplyKeyboardMarkup([[KeyboardButton("‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è")]], resize_keyboard=True)
        await update.message.reply_text(
            f"–î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª: https://t.me/apple_street_41",
            reply_markup=keyboard
        )
        return
    keyboard = ReplyKeyboardMarkup(MAIN_MENU, resize_keyboard=True)
    await update.message.reply_text("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:", reply_markup=keyboard)

async def message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    text = update.message.text.strip()

    if not await is_subscribed(user_id, context):
        keyboard = ReplyKeyboardMarkup([[KeyboardButton("‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è")]], resize_keyboard=True)
        await update.message.reply_text(
            f"–î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª: https://t.me/apple_street_41",
            reply_markup=keyboard
        )
        return

    if user_id in AWAITING_ORDER and AWAITING_ORDER[user_id]:
        await process_order(update, context)
        return

    COMMANDS = {
        "iPhone": handle_iphone,
        "Samsung": handle_samsung,
        "Dyson": handle_dyson,
        "–û—Ç–∑—ã–≤—ã": reviews_handler,
        "üì¶ –°–¥–µ–ª–∞—Ç—å –∑–∞–∫–∞–∑": start_order,
        "üîô –ù–∞–∑–∞–¥": go_back_to_menu,
        "–ú—ã –≤ Telegram": send_telegram_link,
        "–ù–∞—à Instagram": send_instagram_link,
        "‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è": confirm_subscription,
        "–°—Ç–∞–π–ª–µ—Ä—ã": handle_stylers,
    }

    if text in COMMANDS:
        await COMMANDS[text](update, context)
        return

    prices = load_prices()
    if text in prices:
        await send_model_prices(update, context, text)
    else:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –ø—É–Ω–∫—Ç –∏–∑ –º–µ–Ω—é.")

# ========== –û—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–µ–π—Å—Ç–≤–∏–π ==========
async def handle_iphone(update, context):
    prices = load_prices()
    iphone_models = [model for model in prices.keys() if model.startswith("iPhone")]
    keyboard = ReplyKeyboardMarkup([[m] for m in iphone_models] + [["üîô –ù–∞–∑–∞–¥"]], resize_keyboard=True)
    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å iPhone:", reply_markup=keyboard)

async def handle_samsung(update, context):
    prices = load_prices()
    samsung_models = [model for model in prices.keys() if model.startswith("Samsung")]
    keyboard = ReplyKeyboardMarkup([[m] for m in samsung_models] + [["üîô –ù–∞–∑–∞–¥"]], resize_keyboard=True)
    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å Samsung:", reply_markup=keyboard)

async def handle_dyson(update, context):
    keyboard = ReplyKeyboardMarkup(DYSON_CATEGORIES, resize_keyboard=True)
    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é Dyson:", reply_markup=keyboard)

async def handle_stylers(update, context):
    dyson_stylers = load_dyson_stylers()
    response = "–ü—Ä–∞–π—Å –Ω–∞ —Å—Ç–∞–π–ª–µ—Ä—ã Dyson:\n"
    for name, price in dyson_stylers.items():
        response += f"- {name}: {price}\n"
    await update.message.reply_text(response)

async def start_order(update, context):
    user_id = update.effective_user.id
    AWAITING_ORDER[user_id] = True
    await update.message.reply_text("‚úèÔ∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏—Ç–µ, —á—Ç–æ –≤—ã —Ö–æ—Ç–∏—Ç–µ –∑–∞–∫–∞–∑–∞—Ç—å:")

async def go_back_to_menu(update, context):
    keyboard = ReplyKeyboardMarkup(MAIN_MENU, resize_keyboard=True)
    await update.message.reply_text("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=keyboard)

async def send_telegram_link(update, context):
    await update.message.reply_text("–ù–∞—à Telegram –∫–∞–Ω–∞–ª: https://t.me/–≤–∞—à_–∫–∞–Ω–∞–ª")

async def send_instagram_link(update, context):
    await update.message.reply_text("–ù–∞—à Instagram: https://instagram.com/–≤–∞—à_–∏–Ω—Å—Ç–∞–≥—Ä–∞–º")

async def confirm_subscription(update, context):
    user_id = update.effective_user.id
    if await is_subscribed(user_id, context):
        keyboard = ReplyKeyboardMarkup(MAIN_MENU, resize_keyboard=True)
        await update.message.reply_text("–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å:", reply_markup=keyboard)
    else:
        await update.message.reply_text("–í—ã –µ—â–µ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª!")

async def send_model_prices(update, context, model_name):
    prices = load_prices()
    model_info = prices.get(model_name)
    if isinstance(model_info, dict):
        response = f"{model_name}:\n"
        for config, price in model_info.items():
            response += f"- {config}: {price}\n"
        await update.message.reply_text(response)
    else:
        await update.message.reply_text("–ü—Ä–∞–π—Å –ø—É—Å—Ç.")

async def process_order(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    client_username = update.effective_user.username or "–±–µ–∑ username"
    now = datetime.now().strftime("%d.%m.%Y %H:%M")
    text = update.message.text.strip()

    order_text = (
        "üì¶ *–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞*\n"
        f"üë§ *–ö–ª–∏–µ–Ω—Ç:* @{client_username}\n"
        f"üåê *ID:* {user_id}\n"
        f"‚è∞ *–í—Ä–µ–º—è:* {now}\n"
        f"üìù *–ó–∞–∫–∞–∑:* {text}"
    )

    manager_username = "Stella_markova"

    try:
        await context.bot.send_message(
            chat_id=f"@{manager_username}",
            text=order_text,
            parse_mode="Markdown"
        )
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞—è–≤–∫–∏ –º–µ–Ω–µ–¥–∂–µ—Ä—É: {e}")

    await update.message.reply_text("‚úÖ –ó–∞—è–≤–∫–∞ –ø—Ä–∏–Ω—è—Ç–∞! –ú–µ–Ω–µ–¥–∂–µ—Ä —Å–∫–æ—Ä–æ —Å –≤–∞–º–∏ —Å–≤—è–∂–µ—Ç—Å—è.")
    AWAITING_ORDER.pop(user_id, None)

async def reviews_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    review_dir = "reviews"
    if not os.path.exists(review_dir):
        await update.message.reply_text("–ü–∞–ø–∫–∞ —Å –æ—Ç–∑—ã–≤–∞–º–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
        return

    files = sorted([f for f in os.listdir(review_dir) if f.lower().endswith((".jpg", ".jpeg", ".png"))])
    media = []
    for i, filename in enumerate(files):
        path = os.path.join(review_dir, filename)
        with open(path, "rb") as f:
            caption = "üí¨ –û—Ç–∑—ã–≤ –∫–ª–∏–µ–Ω—Ç–∞" if i == 0 else None
            media.append(InputMediaPhoto(f.read(), caption=caption))
    if media:
        await update.message.reply_media_group(media)
    else:
        await update.message.reply_text("–ü–æ–∫–∞ –Ω–µ—Ç –æ—Ç–∑—ã–≤–æ–≤.")

# ========== –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ==========
if __name__ == "__main__":
    app = ApplicationBuilder().token(TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, message_handler))
    app.run_polling()
